
# Parcel Microservice

Микросервис для службы международной доставки, который получает данные о посылках и рассчитывает их стоимость доставки.

## Оглавление

- [Описание](#описание)
- [Установка](#установка)
- [Запуск](#запуск)
- [Технологии](#технологии)
- [Модули маршрутов API](#модули-маршрутов-api)
- [Документация API](#документация-api)
- [Компоненты микросервиса](#компоненты-микросервиса)
- [Эфемерное хранение БД](#эфемерное-хранение-бд)
- [Структура проекта](#структура-проекта)
- [Переменные окружения](#переменные-окружения)
- [Интерфейсы](#интерфейсы)
- [ORM-модели](#orm-модели)
- [Ключевые особенности в выборе типов данных](#ключевые-особенности-в-выборе-типов-данных)
- [Разовый запуск задач Celery вручную](#разовый-запуск-задач-celery-вручную)
- [Отладка webapp](#отладка-webapp)
- [Документация](#документация)
- [Автор](#автор)

## Описание

Микросервис предоставляет следующие функциональные возможности:

- **Регистрация посылки**: Ввод данных о посылке в формате JSON, включая название, вес, тип, и стоимость в долларах. При успешной валидации выдается уникальный ID посылки.
- **Получение информации о типах посылок**: Запрос всех типов посылок, таких как одежда, электроника и разное.
- **Получение списка посылок**: Предоставление списка посылок текущего пользователя с информацией о послыке (включая имя типа посылки), с возможностью пагинации и фильтрации.
- **Получение информации о конкретной посылке**: Детали о посылке, как название, вес, тип, стоимость, и стоимость доставки.

Периодические задачи:

- **Расчет стоимости доставки**: Автоматический пересчет стоимости доставки каждые 5 минут.
- **Курсы валют**: Обновление курса доллара к рублю с кешированием в Redis - раз в час.

При необходимости периодическую задачу можно запустить вручную.

Микросервис не содержит авторизации, для связи с пользователем используется сессия пользователя, в формате UUID.

Для идентификаторов отправления используется ULID благодаря компактности, безопасности и возможности сортировки.

В целях разработки соблюдены некоторые условности:

- Сессия устанавливается в middleware при первом посещении сервиса с устройства (достаточно перейти в /docs).
- В целях отладки хранилище mysql эфемерное, настоящий том не монтируется.
- По прямому id посылки возможно получить информацию о ней без установленной сессии пользователя. Это может быть полезно для получателя, плюс ULID не так просто подобрать. Предполагается, что прямого запрета на просмотр по id чужих посылок нет.
- Информация о владельце посылки ни при получении списком, ни при получении информации об одной посылке не выдается в целях безопасности.
- Более подробно разъяснено ниже, а также в комментариях в коде.
- При интеграции указанные факты должны быть учтены.



## Установка

1. Клонировать репозиторий:
   ```shell
   git clone https://github.com/sergei-kruchinin/parcel.git
   cd parcel
   ```

2. Создать виртуальное окружение и активировать его:
   ```shell
   python3 -m venv .venv
   source .venv/bin/activate  # Для Windows используйте `.venv\Scripts\activate`
   ```

3. Установить зависимости:
   ```shell
   pip install -r requirements.txt   # или используйте poetry
   ```

## Запуск

1. При необходимости перейти в каталог проекта:
   ```shell
   cd parcel
   ```
2. Создать файл .env или скопировать из .env.example:
   ```shell
   cp .env.example .env
   ```

3. Скопировать ORM-модель для сборки Celery:
   ```shell
   bash celery/copy_models.sh
   ```
4. Собрать микросервис с помощью Docker Compose:
   ```shell
   /usr/bin/docker compose -f docker-compose.yml -p parcel up -d
   ```

5. Выполнить миграции:
   ```shell
   alembic upgrade head
   ```

## Технологии
- **Python 3.12** - основной язык разработки.
- **FastAPI** для разработки REST API.
- **Pydantic** для валидации данных.
- **SQLAlchemy** для работы с базой данных.
- **MySQL 9.1** в качестве СУБД для хранения данных о посылках и типах.
- **Redis** для кеширования курсов валют и как брокер для Celery.
- **Celery** для выполнения периодических задач.
- **Docker Compose** для сборки приложения.
- **gunicorn** для запуска веб-приложения в контейнере.
- **Alembic** для выполнения миграций БД.
- **Dotenv** для конфигурации доступка к БД Alembic.
- **Poetry** для управления зависимостями и пакетами.

## Модули маршрутов API

### Модуль: `routes.parcels`

Отвечает за обработку запросов к REST API, связанных с управлением посылками:

- **POST /api/parcels/**:  
  - **Регистрация новой посылки.** 
  - Принимает и валидирует данные в формате JSON, возвращает ULID для идентификации посылки. 
  - Требует пользовательской сессии. Если это первый переход (а не после /docs или другого URL), будет получен ответ 401, запрос придется повторить (так как отработал middleware и выдал сессию).
  - Обработка запроса осуществляется с помощью сервиса `ParcelRegisterService`.

- **GET /api/parcels/**:
  - **Получение списка посылок, связанных с текущим пользователем.**
  - Поддерживает фильтрацию и пагинацию.
  - Требует пользовательскую сессию.
  - Возвращает описание для каждой из посылок, включая имя типа посылки, но исключая id сессии.
  - Если посылок у данного пользователя нет, вернет пустой список.
  - Обработка запросов осуществляется с помощью сервиса `ParcelService`.

- **GET /api/parcels/{parcel_id}/**:  
  - **Предоставление детальной информации о посылке по её ULID.**
  - Пользовательская сессия не проверяется. 
  - Может использоваться получателем без сессии. 
  - Предполагается, что это нормальная функциональность, предоставляемая трекерами отправлений, даже без регистрации. 
  - Возвращает также имя типа посылки, id сессии не выдается.
  - Обработка запроса осуществляется с помощью сервиса `ParcelService`.

### Модуль: `routes.parcel_types`

Определяет маршрут REST API для обработки данных о типах посылок:

- **GET /api/parcels-types**: 
 - **Возвращает список всех типов посылок с их ID и названиями.** 
 - Пользовательская сессия не проверяется. 
 - Обработка запроса осуществляется с помощью сервиса `ParcelTypeService`.  

### Документация API

Документация API доступна в разделе `/docs` с использованием Swagger.

Предоставлены документация входных и выходных данных, описания ошибок.

После старта доступна по адресу http://127.0.0.1:8000/docs


## Компоненты микросервиса

Проект состоит из нескольких контейнеров, описанных в `docker-compose.yml`:

- **webapp**: 
  - Основное приложение на FastAPI. 
  - Доступно через TCP-порт 8000. 
  - Зависит от службы `db` для корректной работы. 

- **redis**: 
  - Используется для кеширования и в качестве брокера сообщений для Celery. 
  - Доступен через TCP-порт 6379.

- **db**: 
  - MySQL база данных для хранения данных о посылках. 
  - Работает на порту 3306. 
  - В целях отладки хранение эфемерное: настоящее хранилище не монтируется.

- **celery**: 
  - Рабочий процесс Celery, обрабатывающий асинхронные задачи, такие как обновление курсов валют и расчет стоимости доставки. 
  - Подключается к `redis` и `db` для выполнения задач.
  - Также может использоваться для запуска разовых задач.

- **celery-beat**: 
  - Планировщик задач Celery, запускающий периодические задания. 
  - Использует `redis` для координации выполнения задач.
  - Делает начальный запуск задачи получения курса валюты.

Контейнеры webapp, redis и db имеют настроенные health checks для проверки готовности контейнера к работе.

### Эфемерное хранение БД

Хранилище mysql эфемерное. При уничтожении контейнера и пересборке не сохраняется.

На практике требуется монтирование каталога с хоста в докер-контейнер, это следует предусмотреть в docker-compose.yml

## Структура проекта

```shell
parcel/
├── alembic/                       # Каталог для миграций базы данных с использованием Alembic
├── alembic.ini                    # Основная конфигурация Alembic
├── celery/                        # Каталог для сборки контейнеров Celery
│   ├── copy_models.sh             # Скрипт для копирования моделей перед сборкой Celery
│   ├── Dockerfile                 # Dockerfile для сборки образа Celery
│   ├── requirements.txt           # Зависимости для выполнения задач Celery
│   └── src/                       # Исходные коды для выполнения задач Celery
│       ├── models/                # Модели для работы с базой данных (копируются из webapp/src)
│       ├── run_tasks.py           # Скрипт для запуска задач вручную
│       └── tasks.py               # Определения задач Celery
├── debug_run_webapp.py            # Скрипт для отладки и запуска webapp локально
├── docker-compose.yml             # Docker Compose файл для сборки и запуска всех зависимостей
├── poetry.lock                    # Зафиксированные версии зависимостей для проекта
├── pyproject.toml                 # Основной файл конфигурации проекта с указанием зависимостей и других настроек
├── README.md                      # Основная документация и описание проекта parcel
├── requirements.txt               # Список зависимостей для проекта (для отладки и сборки)
└── webapp/                        # Каталог для сборки webapp
    ├── Dockerfile                 # Dockerfile для сборки образа webapp
    ├── requirements.txt           # Зависимости для webapp
    └── src/                       # Исходный код webapp
        ├── app.py                 # Основной файл запуска приложения FastAPI + middleware
        ├── exceptions/            # Обработчики и определения ошибок
        │   ├── __init__.py 
        │   ├── error_handlers.py  # Обработчики HTTP ошибок
        │   ├── error_schemas.py   # Pydantic схемы HTTP ошибок
        │   └── exceptions.py      # Классы исключений webapp       
        ├── interfaces/            # Интерфейсы webapp
        │   ├── __init__.py       
        │   └── parcel.py          # Интерфейс для регистрации посылок
        ├── models/                # ORM-модели данных webapp
        │   ├── __init__.py       
        │   ├── base.py            # Базовая модель SQLAlchemy
        │   ├── parcel.py          # ORM-модель данных для посылки
        │   └── parcel_type.py     # ORM-модель данных для типа посылки
        ├── routes/                # Маршруты для API
        │   ├── __init__.py       
        │   ├── dependencies.py    # Зависимости маршрутов
        │   ├── parcels.py         # Маршруты для работы с посылками
        │   └── parcel_types.py    # Маршруты для работы с типами посылок
        ├── schemas/               # Схемы данных для валидации с Pydantic
        │   ├── __init__.py       
        │   ├── parcel.py          # Схемы для посылки
        │   ├── parcel.py          # Схема для типа посылки
        │   └── ulid.py            # Для представления ULID идентификатора
        └── services/              # Сервисы
            ├── __init__.py        #  
            ├── parcel.py          # Получение инфориации о посылках
            ├── parcel_register.py # Регистрация посылок
            └── parcel_type.py     # Получение типов посылок

```

## Переменные окружения
Берутся из .env при сборке docker compose, а также Alembic (благодаря dotenv)
* MYSQL_ROOT_PASSWORD пароль суперпользователя mysql
* MYSQL_DATABASE используемое имя базы данных в mysql
* MYSQL_USER имя пользователя в mysql
* MYSQL_PASSWORD пароль пользователя mysql
* DATABASE_HOST Хост БД для Alembic (для подключения извне контейнера)

## Интерфейсы

Реализация сервиса регистрации посылок в `services/parcel_register` разработана с использованием интерфейса `IParcelRegistryService`. Это позволяет легко расширять и модифицировать функциональность регистрации посылок, добавляя новые реализации, такие как использование очередей сообщений, например, через RabbitMQ или другие системы. 

## ORM-модели
ORM-модели хранятся в webapp/src/models и требуют копирования в celery/src перед установкой. Для этого используется bahs-скрипт celery/copy_models.sh  

Модель реализована с использованием SQLAlchemy для управления данными в базе данных.

## Ключевые особенности в выборе типов данных

- **ID посылки**: 
  - Используется ULID, хранится как строка длиной 26 символов. 
  - ULID обеспечивает уникальность, естественную сортировку и безопасность, поскольку он не позволяет легко предсказать следующий или предыдущий идентификатор.

- **ID сессии пользователя**: 
  - Используется UUID, ожидается в cookie. 
  - Это позволяет идентифицировать пользователей без необходимости авторизации.

- **Вес и стоимости**: 
  - Для хранения веса и стоимости посылки используются поля типа Decimal.
  - Это обеспечивает точность и контроль над форматом чисел (8,3 для веса и 9,2 для стоимостей).

## Пользовательские сессии
Так как приложение не содержит авторизации, для идентификации пользователей используются сессии. Считается, что сессия устанавливается в cookie с именем user_session_id в формате UUID. 

Сессия устанавливается в middleware, если не была установлена. При тестировании REST API через Swagger это произойдет сразу же при обращении к /docs, но при использовании curl следует выполнить хотя бы один запрос (например, запросить список типов посылок).

При интеграции с другими сервисами следует учесть этот момент, в том числе тип сессии, и, при необходимости, удалить middleware из webap/src/app.py

## Отладка webapp
Для отладки webapp можно остановить контейнер parcel_webapp и запустить python скрипт debug_run_webapp.py 

## Разовый запуск задач Celery вручную
В целом не требуется, так как курс валют запрашивается сразу при старте, но при необходимости такая возможность есть.

Для запуска периодических задач вручную следует использовать команды:

- Обновление курса валют:
  ```shell
  docker exec parcel_celery python run_tasks.py --update-exchange-rate
  ```

- Пересчет стоимости доставки:
  ```shell
  docker exec parcel_celery python run_tasks.py --update-shipping-costs
  ```
## Документация
- настоящий README.md - базовое описание проекта и инструкции по его развертыванию
- swagger (/docs) - Документация API
- также проект подробно документирован Docstrings в соответствующих модулях.
## Автор

- **Сергей Кручинин** - [email](mailto:sergeykr@yandex.ru)

 