
# Parcel Microservice

Микросервис для службы международной доставки, который получает данные о посылках и рассчитывает их стоимость доставки.

## Оглавление

- [Описание](#описание)
- [Установка](#установка)
- [Запуск](#запуск)
- [Технологии](#технологии)
- [Модули маршрутов API](#модули-маршрутов-api)
- [Документация API](#документация-api)
- [Компоненты микросервиса](#компоненты-микросервиса)
- [Эфемерное хранение БД](#эфемерное-хранение-бд)
- [Структура проекта](#структура-проекта)
- [Переменные окружения](#переменные-окружения)
- [Интерфейсы](#интерфейсы)
- [ORM-модели](#orm-модели)
- [Ключевые особенности в выборе типов данных](#ключевые-особенности-в-выборе-типов-данных)
- [Внутренние сервисы](#внутренние-сервисы)
- [Разовый запуск задач Celery вручную](#разовый-запуск-задач-celery-вручную)
- [Отладка webapp](#отладка-webapp)
- [Документация](#документация)
- [Автор](#автор)

## Описание

Микросервис предоставляет следующие функциональные возможности:

- **Регистрация посылки**: Ввод данных о посылке в формате **JSON**, включая название, вес, тип, и стоимость в долларах. При успешной валидации выдается уникальный ID посылки.
- **Получение информации о типах посылок**: Запрос всех типов посылок, таких как одежда, электроника и разное.
- **Получение списка посылок**: Предоставление списка посылок текущего пользователя с информацией о посылке (включая имя типа посылки), с возможностью пагинации и фильтрации.
- **Получение информации о конкретной посылке**: Детали о посылке, как название, вес, тип, стоимость, и стоимость доставки.

Периодические задачи:

- **Расчет стоимости доставки**: Автоматический пересчет стоимости доставки каждые 5 минут.
- **Курсы валют**: Обновление курса доллара к рублю с кешированием в Redis - раз в час.

При необходимости периодическую задачу можно запустить вручную.

Микросервис не содержит авторизации, для связи с пользователем используется сессия пользователя, в формате **UUID**.

Для идентификаторов отправления используется **ULID** благодаря компактности, безопасности и возможности сортировки.

В целях разработки соблюдены некоторые условности:

- Сессия устанавливается в middleware при первом посещении сервиса с устройства (достаточно перейти в /docs).
- В целях отладки хранилище MySQL эфемерное, настоящий том не монтируется.
- По прямому ID посылки возможно получить информацию о ней без установленной сессии пользователя. Это может быть полезно для получателя, плюс **ULID** не так просто подобрать. Предполагается, что прямого запрета на просмотр по id чужих посылок нет.
- Информация о владельце посылки ни при получении списком, ни при получении информации об одной посылке не выдается в целях безопасности.
- Более подробно разъяснено ниже, а также в комментариях в коде.
- При интеграции указанные факты должны быть учтены.



## Установка

1. Клонировать репозиторий:
   ```shell
   git clone https://github.com/sergei-kruchinin/parcel.git
   cd parcel
   ```


2. Создать виртуальное окружение и активировать его:
   ```shell
   python3 -m venv .venv
   source .venv/bin/activate  # Для Windows используйте `.venv\Scripts\activate`
   ```

3. Установить зависимости:
   ```shell
   pip install -r requirements.txt   # или используйте poetry
   ```

## Запуск

1. При необходимости перейти в каталог проекта:
   ```shell
   cd parcel
   ```
2. Создать файл .env или скопировать из .env.example:
 ```shell
   cp .env.example .env
   ```
3. Собрать микросервис с помощью Docker Compose:
   ```shell
   /usr/bin/docker compose -f docker-compose.yml -p parcel up -d
   ```
4. Миграции выполняются автоматически при старте контейнера migrate, поэтому дополнительных шагов для их выполнения не требуется.

## Технологии
- **Python 3.12** - основной язык разработки.
- **FastAPI** для разработки REST API.
- **Pydantic** для валидации данных.
- **SQLAlchemy** для работы с базой данных.
- **MySQL 9.1** в качестве СУБД для хранения данных о посылках и типах.
- **Redis** для кеширования курсов валют и как брокер для Celery.
- **Celery** для выполнения периодических задач.
- **Docker Compose** для сборки приложения.
- **gunicorn** для запуска веб-приложения в контейнере.
- **Alembic** для выполнения миграций БД.
- **Dotenv** для конфигурации доступа к БД Alembic.
- **Poetry** для управления зависимостями и пакетами.
- **UUID** для управления уникальными идентификаторами пользовательской сессии без авторизации.
- **ULID** для генерации уникальных идентификаторов посылки.  
## Модули маршрутов API

### Модуль: `routes.parcels`

Отвечает за обработку запросов к REST API, связанных с управлением посылками:

- **POST /api/parcels/**:  
  - **Регистрация новой посылки.** 
  - Принимает и валидирует данные в формате **JSON**, возвращает **ULID** для идентификации посылки. 
  - Требует пользовательской сессии. Если это первый переход (а не после /docs или другого URL), будет получен ответ 401, запрос придется повторить (так как отработал middleware и выдал сессию).
  - Обработка запроса осуществляется с помощью сервиса `ParcelRegisterService`.

- **GET /api/parcels/**:
  - **Получение списка посылок, связанных с текущим пользователем.**
  - Поддерживает фильтрацию и пагинацию.
  - Требует пользовательскую сессию.
  - Возвращает описание для каждой из посылок, включая имя типа посылки, но исключая ID сессии.
  - Если посылок у данного пользователя нет, вернет пустой список.
  - Обработка запросов осуществляется с помощью сервиса `ParcelService`.

- **GET /api/parcels/{parcel_id}/**:  
  - **Предоставление детальной информации о посылке по её ULID.**
  - Пользовательская сессия не проверяется. 
  - Может использоваться получателем без сессии. 
  - Предполагается, что это нормальная функциональность, предоставляемая трекерами отправлений, даже без регистрации. 
  - Возвращает также имя типа посылки, ID сессии не выдается.
  - Обработка запроса осуществляется с помощью сервиса `ParcelService`.

### Модуль: `routes.parcel_types`

Определяет маршрут REST API для обработки данных о типах посылок:

- **GET /api/parcels-types**: 
  - **Возвращает список всех типов посылок с их ID и названиями.** 
  - Пользовательская сессия не проверяется. 
  - Обработка запроса осуществляется с помощью сервиса `ParcelTypeService`.  

### Другие модули

- `routes.healthy`:
  - **GET /api/healthy**:
    - Служит для определения здоровья контейнера (для webapp и internal_services_app)
- `routes.internal_services`:
  - Содержит маршруты для [внутренних сервисов](#внутренние-сервисы)
### Документация API

Документация API доступна в разделе `/docs` с использованием Swagger.

Предоставлены документация входных и выходных данных, описания ошибок.

После старта доступна по адресу http://127.0.0.1:8000/docs


## Компоненты микросервиса

Проект состоит из нескольких контейнеров, описанных в `docker-compose.yml`:

- **webapp**: 
  - Основное приложение на FastAPI. 
  - Доступно через TCP-порт 8000. 
  - Зависит от службы `db` и службы `migrate` для корректной работы.

- **migrate**:

  - Контейнер, отвечающий за выполнение миграций базы данных с помощью Alembic.
  - Выполняет команду alembic upgrade head для применения всех миграций при запуске.
  - Запускается перед `webapp`, чтобы гарантировать, что база данных находится в актуальном состоянии.
  - После выполнения своей задачи завершается.
  - Зависит от службы `db` для корректной работы. 

- **redis**: 
  - Используется для кеширования и в качестве брокера сообщений для Celery. 
  - Доступен через TCP-порт 6379.

- **db**: 
  - MySQL база данных для хранения данных о посылках. 
  - Работает на порту 3306. 
  - В целях отладки хранение эфемерное: настоящее хранилище не монтируется.

- **celery**: 
  - Рабочий процесс Celery, обрабатывающий асинхронные задачи, такие как обновление курсов валют и расчет стоимости доставки.
  - Также может использоваться для запуска разовых задач.

- **celery-beat**: 
  - Планировщик задач Celery, запускающий периодические задания. 
  - Использует `redis` для координации выполнения задач.
  - Делает начальный запуск задачи получения курса валюты.

- **internal_services_app**: 
  - Внутренние маршруты для Celery.
  - Авторизация пока не реализована
  - Подключается к `redis` и `db` для выполнения задач.
  - Использует `redis` для кеширования курса валют.
    
Контейнеры webapp, redis, db и internal_services_app имеют настроенные health checks для проверки готовности контейнера к работе.

### Эфемерное хранение БД

Хранилище MySQL эфемерное. При уничтожении контейнера и пересборке не сохраняется.

На практике требуется монтирование каталога с хоста в докер-контейнер, это следует предусмотреть в docker-compose.yml

## Структура проекта

```shell
parcel/
├── celery/                            # Каталог для сборки контейнеров Celery
│   ├── Dockerfile                     # Dockerfile для сборки образа Celery
│   ├── requirements.txt               # Зависимости для выполнения задач Celery
│   └── src/                           # Исходные коды для выполнения задач Celery
│       ├── models/                    # Модели для работы с базой данных (копируются из webapp/src)
│       ├── run_tasks.py               # Скрипт для запуска задач вручную
│       └── tasks.py                   # Определения задач Celery
├── debug_run_webapp.py                # Скрипт для отладки и запуска webapp локально
├── docker-compose.yml                 # Docker Compose файл для сборки и запуска всех зависимостей
├── poetry.lock                        # Зафиксированные версии зависимостей для проекта
├── pyproject.toml                     # Основной файл конфигурации проекта с указанием зависимостей и других настроек
├── README.md                          # Основная документация и описание проекта parcel
├── requirements.txt                   # Список зависимостей для проекта (для отладки и сборки)
└── webapp/                            # Каталог для сборки webapp
    ├── Dockerfile                     # Dockerfile для сборки образа webapp
    ├── requirements.txt               # Зависимости для webapp
    ├── alembic/                       # Каталог для миграций базы данных с использованием Alembic
    ├── alembic.ini                    # Основная конфигурация Alembic
    └── src/                           # Исходный код webapp
        ├── app.py                     # Основной файл запуска приложения FastAPI + middleware
        ├── config/                    # Конфигурация
        │   ├── __init__.py      
        │   └── pricing_conf.py        # Конфигурация для расчета стоимости доставки    
        ├── exceptions/                # Обработчики и определения ошибок
        │   ├── __init__.py 
        │   ├── error_handlers.py      # Обработчики HTTP ошибок
        │   ├── error_schemas.py       # Pydantic схемы HTTP ошибок
        │   └── exceptions.py          # Классы исключений webapp       
        ├── interfaces/                # Интерфейсы для сервисов
        │   ├── __init__.py      
        │   ├── cache.py               # Интерфейс для кэширования 
        │   └── parcel.py              # Интерфейс для регистрации посылок
        ├── models/                    # ORM-модели данных webapp
        │   ├── __init__.py       
        │   ├── base.py                # Базовая модель SQLAlchemy
        │   ├── parcel.py              # ORM-модель данных для посылки
        │   └── parcel_type.py         # ORM-модель данных для типа посылки
        ├── routes/                    # Маршруты для API
        │   ├── __init__.py       
        │   ├── healthy.py             # Проверка состояния сервиса
        │   ├── dependencies.py        # Зависимости маршрутов
        │   ├── internal_services.py   # Служебные маршруты
        │   ├── parcels.py             # Маршруты для работы с посылками
        │   └── parcel_types.py        # Маршруты для работы с типами посылок
        ├── schemas/                   # Схемы данных для валидации с Pydantic
        │   ├── __init__.py       
        │   ├── parcel.py              # Схемы для посылки
        │   ├── parcel_types.py        # Схема для типа посылки
        │   ├── healthy.py             # Схема для предоставления healthy ответа
        │   ├── statuses.py            # Схемы успешных статусов
        │   └── ulid.py                # Схема для представления ULID идентификатора
        └── services/                  # Сервисы
            ├── __init__.py         
            ├── currency_fetch.py      # Логика получения курса валют из URL
            ├── currency_redis.py      # Работа с Redis для курса валют
            ├── currency_service.py    # Сервис для работы с курсом валют
            ├── parcel.py              # Получение информации о посылках
            ├── parcel_register.py     # Регистрация посылок
            ├── parcel_type.py         # Управление типами посылок
            ├── redis_wrapper.py       # Обертка для работы с Redis
            └── shipping_costs_update_service.py # Обновление стоимости доставки

```

## Переменные окружения
Берутся из .env при сборке docker compose, а также Alembic (благодаря Dotenv).
* MYSQL_ROOT_PASSWORD: пароль суперпользователя MySQL.
* MYSQL_DATABASE: используемое имя базы данных в MySQL.
* MYSQL_USER: имя пользователя в MySQL.
* MYSQL_PASSWORD: пароль пользователя MySQL.
* DATABASE_HOST: хост БД (MySQL) для Alembic (для подключения извне контейнера).
* USD_EXCHANGE_API_URL: URL для получения курса валют 
* USD_EXCHANGE_INTERVAL: Интервал обновления курса валют в секундах
* SHIPPING_COST_UPDATE_INTERVAL: Интервал рассчета стоимости доставки в секундах
Пример .env (приведен в файле .env.example:
```bash
MYSQL_ROOT_PASSWORD=root_secure_password321
MYSQL_DATABASE=app_database
MYSQL_USER=app_user
MYSQL_PASSWORD=secure_password123
DATABASE_HOST=localhost
USD_EXCHANGE_API_URL=https://www.cbr-xml-daily.ru/daily_json.js
USD_EXCHANGE_INTERVAL=3600
SHIPPING_COST_UPDATE_INTERVAL=300

```
## Интерфейсы

Реализация сервиса регистрации посылок в `services/parcel_register` разработана с использованием интерфейса `IParcelRegistryService`. Это позволяет легко расширять и модифицировать функциональность регистрации посылок, добавляя новые реализации, такие как использование очередей сообщений, например, через RabbitMQ или другие системы. 

## ORM-модели
ORM-модели находятся в `webapp/src/models`. 
 
Модели реализованы с использованием SQLAlchemy.


## Ключевые особенности в выборе типов данных

- **ID посылки**: 
  - Используется **ULID**, хранится как строка длиной 26 символов. 
  - **ULID** обеспечивает уникальность, естественную сортировку и безопасность, поскольку он не позволяет легко предсказать следующий или предыдущий идентификатор.

- **ID сессии пользователя**: 
  - Используется **UUID**, ожидается в cookie. 
  - Это позволяет идентифицировать пользователей без необходимости авторизации.

- **Вес и стоимости**: 
  - Для хранения веса и стоимости посылки используются поля типа **Decimal**.
  - Это обеспечивает точность и контроль над форматом чисел (8,3 для веса и 9,2 для стоимостей).

## Пользовательские сессии
Так как приложение не содержит авторизации, для идентификации пользователей используются сессии. Считается, что сессия устанавливается в cookie с именем user_session_id в формате **UUID**. 

Сессия устанавливается в middleware, если не была установлена. При тестировании REST API через Swagger это произойдет сразу же при обращении к /docs, но при использовании curl следует выполнить хотя бы один запрос (например, запросить список типов посылок).

При интеграции с другими сервисами следует учесть этот момент, в том числе тип сессии, и, при необходимости, удалить middleware из webap/src/app.py

## Отладка webapp
Для отладки webapp можно остановить контейнер parcel_webapp и запустить python скрипт debug_run_webapp.py 

## Внутренние сервисы

Используются для регулярных и разовых задач. Celery вызывает служебные маршруты internal_services_app.

На данный момент авторизация между сервисами не реализовано (предполагается, что nginx не будет направлять запросы на внутренние сервисы из внешней сети). 

В дальнейшем следует реализовать авторизацию между сервисами.

Внутренние сервисы:

1. Celery

   Файлы:

   - celery/src/run_tasks.py: Скрипт для запуска Celery worker.
   - celery/src/tasks.py: Определение фоновых задач.

   Основные задачи:

   - update_usd_rate: Обновление курса доллара.
   - update_shipping_costs: Перерасчет стоимости доставки.

2. internal_services_app

   Точка входа:
   - webapp/src/internal_services_app.py

   Маршруты API:

   - /api/update_usd_rate: Обновляет курс доллара в Redis.
   - /api/update_shipping_costs: Пересчитывает стоимость доставки.
   - /api/healthy: Служит для мониторинга состояния контейнера

   Файлы:
   - interfaces/cache.py: Интерфейс для работы с кешем.
   - pricing_conf.py: Конфигурация для расчета стоимости доставки
   - services/currency_fetch.py: Получение курса валют с API.
   - services/currency_redis.py: Кэширование курса валют в Redis.
   - services/currency_service.py: Логика обновления и получения курса валют.
   - services/shipping_costs_update_service.py: Пересчет стоимости доставки.
   
## Разовый запуск задач Celery вручную
В целом не требуется, так как курс валют запрашивается сразу при старте, но при необходимости такая возможность есть.

Для запуска периодических задач вручную следует использовать команды:

- Обновление курса валют:
  ```shell
  docker exec parcel_celery python run_tasks.py --update-exchange-rate
  ```

- Пересчет стоимости доставки:
  ```shell
  docker exec parcel_celery python run_tasks.py --update-shipping-costs
  ```
  
- Также в целях отладки возможен через прямой вызов маршрутов через http://127.0.0.1:8008/docs
## Документация
- настоящий README.md - базовое описание проекта и инструкции по его развертыванию
- swagger (/docs) - Документация API
- также проект подробно документирован Docstrings в соответствующих модулях.
## Автор

- **Сергей Кручинин** - [email](mailto:sergeykr@yandex.ru)

 